--------------------------------------------
:mod:`pg` --- The Classic PyGreSQL Interface
--------------------------------------------

.. module:: pg

.. contents:: Contents


Introduction
============
You may either choose to use the "classic" PyGreSQL interface
provided by the :mod:`pg` module or else the
DB-API 2.0 compliant interface provided by the :mod:`pgdb` module.

The following part of the documentation covers only the older :mod:`pg` API.

The :mod:`pg` module handles three types of objects,

- the :class:`Connection` instances, which handle the connection
  and all the requests to the database,
- the :class:`LargeObject` instances, which handle
  all the accesses to PostgreSQL large objects,
- the :class:`Query` instances that handle query results

and it provides a convenient wrapper class :class:`DB`
for the basic :class:`Connection` class.

If you want to see a simple example of the use of some of these functions,
please have a look at the :doc:`examples`.


Module functions and constants
==============================

The :mod:`pg` module defines a few functions that allow to connect
to a database and to define "default variables" that override
the environment variables used by PostgreSQL.

These "default variables" were designed to allow you to handle general
connection parameters without heavy code in your programs. You can prompt the
user for a value, put it in the default variable, and forget it, without
having to modify your environment. The support for default variables can be
disabled by setting the ``-DNO_DEF_VAR`` option in the Python setup file.
Methods relative to this are specified by the tag [DV].

All variables are set to ``None`` at module initialization, specifying that
standard environment variables should be used.

connect -- Open a PostgreSQL connection
---------------------------------------

.. function:: connect([dbname], [host], [port], [opt], [tty], [user], [passwd])

    Open a :mod:`pg` connection

    :param dbname: name of connected database (*None* = :data:`defbase`)
    :type str: str or None
    :param host: name of the server host (*None* = :data:`defhost`)
    :type host:  str or None
    :param port: port used by the database server (-1 = :data:`defport`)
    :type port: int
    :param opt: connection options (*None* = :data:`defopt`)
    :type opt: str or None
    :param tty: debug terminal (*None* = :data:`deftty`)
    :type tty: str or None
    :param user: PostgreSQL user (*None* = :data:`defuser`)
    :type user: str or None
    :param passwd: password for user (*None* = :data:`defpasswd`)
    :type passwd: str or None
    :returns: If successful, the :class:`Connection` handling the connection
    :rtype: :class:`Connection`
    :raises TypeError: bad argument type, or too many arguments
    :raises SyntaxError: duplicate argument definition
    :raises pg.InternalError: some error occurred during pg connection definition
    :raises Exception: (all exceptions relative to object allocation)

This function opens a connection to a specified database on a given
PostgreSQL server. You can use keywords here, as described in the
Python tutorial. The names of the keywords are the name of the
parameters given in the syntax line. For a precise description
of the parameters, please refer to the PostgreSQL user manual.

Example::

    import pg

    con1 = pg.connect('testdb', 'myhost', 5432, None, None, 'bob', None)
    con2 = pg.connect(dbname='testdb', host='localhost', user='bob')

get/set_defhost -- default server host [DV]
-------------------------------------------

.. function:: get_defhost(host)

    Get the default host

    :returns: the current default host specification
    :rtype: str or None
    :raises TypeError: too many arguments

This method returns the current default host specification,
or ``None`` if the environment variables should be used.
Environment variables won't be looked up.

.. function:: set_defhost(host)

    Set the default host

    :param host: the new default host specification
    :type host: str or None
    :returns: the previous default host specification
    :rtype: str or None
    :raises TypeError: bad argument type, or too many arguments

This methods sets the default host value for new connections.
If ``None`` is supplied as parameter, environment variables will
be used in future connections. It returns the previous setting
for default host.

get/set_defport -- default server port [DV]
-------------------------------------------

.. function:: get_defport()

    Get the default port

    :returns: the current default port specification
    :rtype: int
    :raises TypeError: too many arguments

This method returns the current default port specification,
or ``None`` if the environment variables should be used.
Environment variables won't be looked up.

.. function::  set_defport(port)

    Set the default port

    :param port: the new default port
    :type port: int
    :returns: previous default port specification
    :rtype: int or None

This methods sets the default port value for new connections. If -1 is
supplied as parameter, environment variables will be used in future
connections. It returns the previous setting for default port.

get/set_defopt --  default connection options [DV]
--------------------------------------------------

.. function:: get_defopt()

    Get the default connection options

    :returns: the current default options specification
    :rtype: str or None
    :raises TypeError: too many arguments

This method returns the current default connection options  specification,
or ``None`` if the environment variables should be used. Environment variables
won't be looked up.

.. function:: set_defopt(options)

    Set the default connection options

    :param options: the new default connection options
    :type options: str or None
    :returns: previous default options specification
    :rtype: str or None
    :raises TypeError: bad argument type, or too many arguments

This methods sets the default connection options value for new connections.
If ``None`` is supplied as parameter, environment variables will be used in
future connections. It returns the previous setting for default options.

get/set_deftty -- default debug tty [DV]
----------------------------------------

.. function:: get_deftty()

    Get the default debug terminal

    :returns: the current default debug terminal specification
    :rtype: str or None
    :raises TypeError: too many arguments

This method returns the current default debug terminal specification, or
``None`` if the environment variables should be used. Environment variables
won't be looked up.

.. function:: set_deftty(terminal)

    Set the default debug terminal

    :param terminal: the new default debug terminal
    :type terminal: str or None
    :returns: the previous default debug terminal specification
    :rtype: str or None
    :raises TypeError: bad argument type, or too many arguments

This methods sets the default debug terminal value for new connections.
If ``None`` is supplied as parameter, environment variables will be used
in future connections. It returns the previous setting for default terminal.

get/set_defbase -- default database name [DV]
---------------------------------------------

.. function:: get_defbase()

    Get the default database name

    :returns: the current default database name specification
    :rtype: str or None
    :raises TypeError: too many arguments

This method returns the current default database name specification, or
``None`` if the environment variables should be used. Environment variables
won't be looked up.

.. function:: set_defbase(base)

    Set the default database name

    :param base: the new default base name
    :type base: str or None
    :returns: the previous default database name specification
    :rtype: str or None
    :raises TypeError: bad argument type, or too many arguments

This method sets the default database name value for new connections. If
``None`` is supplied as parameter, environment variables will be used in
future connections. It returns the previous setting for default host.

get/set_defuser -- default database user [DV]
---------------------------------------------

.. function:: get_defuser()

    Get the default database user

    :returns: the current default database user specification
    :rtype: str or None
    :raises TypeError: too many arguments

This method returns the current default database user specification, or
``None`` if the environment variables should be used. Environment variables
won't be looked up.

.. function:: set_defuser(user)

    Set the default database user

    :param user: the new default database user
    :type base: str or None
    :returns: the previous default database user specification
    :rtype: str or None
    :raises TypeError: bad argument type, or too many arguments

This method sets the default database user name for new connections. If
``None`` is supplied as parameter, environment variables will be used in
future connections. It returns the previous setting for default host.

get/set_defpasswd -- default database password [DV]
---------------------------------------------------

.. function:: get_defpasswd()

    Get the default database password

    :returns: the current default database password specification
    :rtype: str or None
    :raises TypeError: too many arguments

This method returns the current default database password specification, or
``None`` if the environment variables should be used. Environment variables
won't be looked up.

.. function:: set_defpasswd(passwd)

    Set the default database password

    :param passwd: the new default database password
    :type base: str or None
    :returns: the previous default database password specification
    :rtype: str or None
    :raises TypeError: bad argument type, or too many arguments

This method sets the default database password for new connections. If
``None`` is supplied as parameter, environment variables will be used in
future connections. It returns the previous setting for default host.

escape_string -- escape a string for use within SQL
---------------------------------------------------

.. function:: escape_string(string)

    Escape a string for use within SQL

    :param str string: the string that is to be escaped
    :returns: the escaped string
    :rtype: str
    :raises TypeError: bad argument type, or too many arguments

This function escapes a string for use within an SQL command.
This is useful when inserting data values as literal constants
in SQL commands. Certain characters (such as quotes and backslashes)
must be escaped to prevent them from being interpreted specially
by the SQL parser. :func:`escape_string` performs this operation.
Note that there is also a :class:`Connection` method with the same name
which takes connection properties into account.

.. note::

   It is especially important to do proper escaping when
   handling strings that were received from an untrustworthy source.
   Otherwise there is a security risk: you are vulnerable to "SQL injection"
   attacks wherein unwanted SQL commands are fed to your database.

Example::

    name = input("Name? ")
    phone = con.query("select phone from employees where name='%s'"
        % escape_string(name)).getresult()

escape_bytea -- escape binary data for use within SQL
-----------------------------------------------------

.. function:: escape_bytea(datastring)

    escape binary data for use within SQL as type ``bytea``

    :param str datastring: string containing the binary data that is to be escaped
    :returns: the escaped string
    :rtype: str
    :raises TypeError: bad argument type, or too many arguments

Escapes binary data for use within an SQL command with the type ``bytea``.
As with :func:`escape_string`, this is only used when inserting data directly
into an SQL command string.
Note that there is also a :class:`Connection` method with the same name
which takes connection properties into account.

Example::

    picture = open('garfield.gif', 'rb').read()
    con.query("update pictures set img='%s' where name='Garfield'"
        % escape_bytea(picture))

unescape_bytea -- unescape data that has been retrieved as text
---------------------------------------------------------------

.. function:: unescape_bytea(string)

    Unescape ``bytea`` data that has been retrieved as text

    :param str datastring: the ``bytea`` data string that has been retrieved as text
    :returns: byte string containing the binary data
    :rtype: bytes
    :raises TypeError: bad argument type, or too many arguments

Converts an escaped string representation of binary data into binary
data -- the reverse of :func:`escape_bytea`. This is needed when retrieving
``bytea`` data with one of the :meth:`Query.getresult`,
:meth:`Query.dictresult` or :meth:`Query.namedresult` methods.

Example::

    picture = unescape_bytea(con.query(
          "select img from pictures where name='Garfield'").getresult[0][0])
    open('garfield.gif', 'wb').write(picture)

get/set_decimal -- decimal type to be used for numeric values
-------------------------------------------------------------

.. function:: get_decimal()

    Get the decimal type to be used for numeric values

    :returns: the Python class used for PostgreSQL numeric values
    :rtype: class

This function returns the Python class that is used by PyGreSQL to hold
PostgreSQL numeric values. The default class is :class:`decimal.Decimal`
if available, otherwise the :class:`float` type is used.

.. function:: set_decimal(cls)

    Set a decimal type to be used for numeric values

    :param class cls: the Python class to be used for PostgreSQL numeric values

This function can be used to specify the Python class that shall
be used by PyGreSQL to hold PostgreSQL numeric values.
The default class is :class:`decimal.Decimal` if available,
otherwise the :class:`float` type is used.

get/set_decimal_point -- decimal mark used for monetary values
--------------------------------------------------------------

.. function:: get_decimal_point()

    Get the decimal mark used for monetary values

    :returns: string with one character representing the decimal mark
    :rtype: str

This function returns the decimal mark used by PyGreSQL to interpret
PostgreSQL monetary values when converting them to decimal numbers.
The default setting is ``'.'`` as a decimal point. This setting is not
adapted automatically to the locale used by PostGreSQL, but you can
use ``set_decimal()`` to set a different decimal mark manually. A return
value of ``None`` means monetary values are not interpreted as decimal
numbers, but returned as strings including the formatting and currency.

.. function:: set_decimal_point(string)

    Specify which decimal mark is used for interpreting monetary values

    :param str string: string with one character representing the decimal mark

This function can be used to specify the decimal mark used by PyGreSQL
to interpret PostgreSQL monetary values. The default value is '.' as
a decimal point. This value is not adapted automatically to the locale
used by PostGreSQL, so if you are dealing with a database set to a
locale that uses a ``','`` instead of ``'.'`` as the decimal point,
then you need to call ``set_decimal(',')`` to have PyGreSQL interpret
monetary values correctly. If you don't want money values to be converted
to decimal numbers, then you can call ``set_decimal(None)``, which will
cause PyGreSQL to return monetary values as strings including their
formatting and currency.

get/set_bool -- whether boolean values are returned as bool objects
-------------------------------------------------------------------

.. function:: get_bool()

    Check whether boolean values are returned as bool objects

    :returns: whether or not bool objects will be returned
    :rtype: bool

This function checks whether PyGreSQL returns PostgreSQL boolean
values converted to Python bool objects, or as ``'f'`` and ``'t'``
strings which are the values used internally by PostgreSQL. By default,
conversion to bool objects is not activated, but you can enable
this with the ``set_bool()`` method.

.. function:: set_bool(on)

    Set whether boolean values are returned as bool objects

    :param on: whether or not bool objects shall be returned

This function can be used to specify whether PyGreSQL shall return
PostgreSQL boolean values converted to Python bool objects, or as
``'f'`` and ``'t'`` strings which are the values used internally by PostgreSQL.
By default, conversion to bool objects is not activated, but you can
enable this by calling ``set_bool(True)``.

get/set_namedresult -- conversion to named tuples
-------------------------------------------------

.. function:: get_namedresult()

    Get the function that converts to named tuples

This function returns the function used by PyGreSQL to construct the
result of the :meth:`Query.namedresult` method.

.. function:: set_namedresult(func)

    Set a function that will convert to named tuples

    :param func: the function to be used to convert results to named tuples

You can use this if you want to create different kinds of named tuples
returned by the :meth:`Query.namedresult` method.


Module constants
----------------
Some constants are defined in the module dictionary.
They are intended to be used as parameters for methods calls.
You should refer to the libpq description in the PostgreSQL user manual
for more information about them. These constants are:

.. data:: version, __version__

    constants that give the current version

.. data:: INV_READ, INV_WRITE

    large objects access modes,
    used by :meth:`Connection.locreate` and :meth:`LargeObject.open`

.. data:: SEEK_SET, SEEK_CUR, SEEK_END:

    positional flags, used by :meth:`LargeObject.seek`


Connection -- The connection object
=================================

.. class:: Connection

This object handles a connection to a PostgreSQL database. It embeds and
hides all the parameters that define this connection, thus just leaving really
significant parameters in function calls.

.. note::

    Some methods give direct access to the connection socket.
    *Do not use them unless you really know what you are doing.*
    If you prefer disabling them,
    set the ``-DNO_DIRECT`` option in the Python setup file.
    These methods are specified by the tag [DA].

.. note::

    Some other methods give access to large objects
    (refer to PostgreSQL user manual for more information about these).
    If you want to forbid access to these from the module,
    set the ``-DNO_LARGE`` option in the Python setup file.
    These methods are specified by the tag [LO].

query -- execute a SQL command string
-------------------------------------

.. method:: Connection.query(command, [args])

    Execute a SQL command string

    :param str command: SQL command
    :param args: optional positional arguments
    :returns: result values
    :rtype: :class:`Query`, None
    :raises TypeError: bad argument type, or too many arguments
    :raises TypeError: invalid connection
    :raises ValueError: empty SQL query or lost connection
    :raises pg.ProgrammingError: error in query
    :raises pg.InternalError: error during query processing

This method simply sends a SQL query to the database. If the query is an
insert statement that inserted exactly one row into a table that has OIDs, the
return value is the OID of the newly inserted row. If the query is an update
or delete statement, or an insert statement that did not insert exactly one
row in a table with OIDs, then the number of rows affected is returned as a
string. If it is a statement that returns rows as a result (usually a select
statement, but maybe also an ``"insert/update ... returning"`` statement),
this method returns a :class:`Query` that can be accessed via the
:meth:`Query.getresult`, :meth:`Query.dictresult` or
:meth:`Query.namedresult` methods or simply printed.
Otherwise, it returns ``None``.

The query may optionally contain positional parameters of the form ``$1``,
``$2``, etc instead of literal data, and the values supplied as a tuple.
The values are substituted by the database in such a way that they don't
need to be escaped, making this an effective way to pass arbitrary or
unknown data without worrying about SQL injection or syntax errors.

When the database could not process the query, a :exc:`pg.ProgrammingError` or
a :exc:`pg.InternalError` is raised. You can check the ``SQLSTATE`` code of
this error by reading its :attr:`sqlstate` attribute.

Example::

    name = input("Name? ")
    phone = con.query("select phone from employees where name=$1",
        (name,)).getresult()

reset -- reset the connection
-----------------------------

.. method:: Connection.reset()

    Reset the :mod:`pg` connection
    
    :rtype: None
    :raises TypeError: too many (any) arguments
    :raises TypeError: invalid connection

This method resets the current database connection.

cancel -- abandon processing of current SQL command
---------------------------------------------------

.. method:: Connection.cancel()

    :rtype: None
    :raises TypeError: too many (any) arguments
    :raises TypeError: invalid connection

This method requests that the server abandon processing
of the current SQL command.

close -- close the database connection
--------------------------------------

.. method:: Connection.close()

    Close the :mod:`pg` connection
    
    :rtype: None
    :raises TypeError: too many (any) arguments

This method closes the database connection. The connection will
be closed in any case when the connection is deleted but this
allows you to explicitly close it. It is mainly here to allow
the DB-SIG API wrapper to implement a close function.

fileno -- returns the socket used to connect to the database
------------------------------------------------------------

.. method:: Connection.fileno()

   Return the socket used to connect to the database

   :returns: the socket id of the database connection
   :rtype: int
   :raises TypeError: too many (any) arguments
   :raises TypeError: invalid connection

This method returns the underlying socket id used to connect
to the database. This is useful for use in select calls, etc.

getnotify -- get the last notify from the server
------------------------------------------------

.. method:: Connection.getnotify()

    Get the last notify from the server

    :returns: last notify from server
    :rtype: tuple, None
    :raises TypeError: too many parameters
    :raises TypeError: invalid connection

This method tries to get a notify from the server (from the SQL statement
NOTIFY). If the server returns no notify, the methods returns None.
Otherwise, it returns a tuple (triplet) *(relname, pid, extra)*, where
*relname* is the name of the notify, *pid* is the process id of the
connection that triggered the notify, and *extra* is a payload string
that has been sent with the notification. Remember to do a listen query
first, otherwise :meth:`Connection.getnotify` will always return ``None``.

inserttable -- insert a list into a table
-----------------------------------------

.. method:: Connection.inserttable(table, values)

    Insert a Python list into a database table

    :param str table: the table name
    :param list values: list of rows values
    :rtype: None
    :raises TypeError: invalid connection, bad argument type, or too many arguments
    :raises MemoryError: insert buffer could not be allocated
    :raises ValueError: unsupported values

This method allows to *quickly* insert large blocks of data in a table:
It inserts the whole values list into the given table. Internally, it
uses the COPY command of the PostgreSQL database. The list is a list
of tuples/lists that define the values for each inserted row. The rows
values may contain string, integer, long or double (real) values.

.. note::

    **Be very careful**:
    This method doesn't type check the fields according to the table definition;
    it just look whether or not it knows how to handle such types.

get/set_notice_receiver -- custom notice receiver
-------------------------------------------------

.. method:: Connection.get_notice_receiver()

    Get the current notice receiver

    :returns: the current notice receiver callable
    :rtype: callable, None
    :raises TypeError: too many (any) arguments

This method gets the custom notice receiver callback function that has
been set with :meth:`Connection.set_notice_receiver`, or ``None`` if no
custom notice receiver has ever been set on the connection.

.. method:: Connection.set_notice_receiver(proc)

    Set a custom notice receiver

    :param proc: the custom notice receiver callback function
    :rtype: None
    :raises TypeError: the specified notice receiver is not callable

This method allows setting a custom notice receiver callback function.
When a notice or warning message is received from the server,
or generated internally by libpq, and the message level is below
the one set with ``client_min_messages``, the specified notice receiver
function will be called. This function must take one parameter,
the :class:`Notice` object, which provides the following read-only
attributes:

    .. attribute:: Notice.pgcnx

        the connection

    .. attribute:: Notice.message

        the full message with a trailing newline

    .. attribute:: Notice.severity

        the level of the message, e.g. 'NOTICE' or 'WARNING'

    .. attribute:: Notice.primary

        the primary human-readable error message

    .. attribute:: Notice.detail

        an optional secondary error message

    .. attribute:: Notice.hint

        an optional suggestion what to do about the problem

putline -- write a line to the server socket [DA]
-------------------------------------------------

.. method:: Connection.putline(line)

    Write a line to the server socket

    :param str line: line to be written
    :rtype: None
    :raises TypeError: invalid connection, bad parameter type, or too many parameters

This method allows to directly write a string to the server socket.

getline -- get a line from server socket [DA]
---------------------------------------------

.. method:: Connection.getline()

    Get a line from server socket

    :returns:  the line read
    :rtype: str
    :raises TypeError: invalid connection
    :raises TypeError: too many parameters
    :raises MemoryError: buffer overflow

This method allows to directly read a string from the server socket.

endcopy -- synchronize client and server [DA]
---------------------------------------------

.. method:: Connection.endcopy()

    Synchronize client and server

    :rtype: None
    :raises TypeError: invalid connection
    :raises TypeError: too many parameters

The use of direct access methods may desynchronize client and server.
This method ensure that client and server will be synchronized.

locreate -- create a large object in the database [LO]
------------------------------------------------------

.. method:: Connection.locreate(mode)

    Create a large object in the database

    :param int mode: large object create mode
    :returns: object handling the PostGreSQL large object
    :rtype: :class:`LargeObject`
    :raises TypeError: invalid connection, bad parameter type, or too many parameters
    :raises pg.OperationalError: creation error

This method creates a large object in the database. The mode can be defined
by OR-ing the constants defined in the :mod:`pg` module (:const:`INV_READ`,
:const:`INV_WRITE` and :const:`INV_ARCHIVE`). Please refer to PostgreSQL
user manual for a description of the mode values.

getlo -- build a large object from given oid [LO]
-------------------------------------------------

.. method:: Connection.getlo(oid)

    Create a large object in the database

    :param int oid: OID of the existing large object
    :returns: object handling the PostGreSQL large object
    :rtype: :class:`LargeObject`
    :raises TypeError:  invalid connection, bad parameter type, or too many parameters
    :raises ValueError: bad OID value (0 is invalid_oid)

This method allows to reuse a formerly created large object through the
:class:`LargeObject` interface, providing the user have its OID.

loimport -- import a file to a large object [LO]
------------------------------------------------

.. method:: Connection.loimport(name)

    Import a file to a large object

    :param str name: the name of the file to be imported
    :returns: object handling the PostGreSQL large object
    :rtype: :class:`LargeObject`
    :raises TypeError: invalid connection, bad argument type, or too many arguments
    :raises pg.OperationalError: error during file import

This methods allows to create large objects in a very simple way. You just
give the name of a file containing the data to be used.

Object attributes
-----------------
Every :class:`Connection` defines a set of read-only attributes that describe
the connection and its status. These attributes are:

.. attribute:: Connection.host

   the host name of the server (str)

.. attribute:: Connection.port

   the port of the server (int)

.. attribute:: Connection.db

   the selected database (str)

.. attribute:: Connection.options

   the connection options (str)

.. attribute:: Connection.tty

   the connection debug terminal (str)

.. attribute:: Connection.user

    user name on the database system (str)

.. attribute:: Connection.protocol_version

   the frontend/backend protocol being used (int)

.. attribute:: Connection.server_version

   the backend version (int, e.g. 80305 for 8.3.5)

.. attribute:: Connection.status

   the status of the connection (int: 1 = OK, 0 = bad)

.. attribute:: Connection.error

   the last warning/error message from the server (str)


The DB wrapper class
====================

.. class:: DB

The :class:`Connection` methods are wrapped in the class :class:`DB`.
The preferred way to use this module is as follows::

    import pg

    db = pg.DB(...)  # see below

    for r in db.query(  # just for example
        """SELECT foo,bar
         FROM foo_bar_table
         WHERE foo !~ bar"""
        ).dictresult():

        print '%(foo)s %(bar)s' % r

This class can be subclassed as in this example::

    import pg

    class DB_ride(pg.DB):
        """Ride database wrapper

        This class encapsulates the database functions and the specific
        methods for the ride database."""

    def __init__(self):
        """Open a database connection to the rides database"""
        pg.DB.__init__(self, dbname='ride')
        self.query("SET DATESTYLE TO 'ISO'")

    [Add or override methods here]

The following describes the methods and variables of this class.

Initialization
--------------
The :class:`DB` class is initialized with the same arguments as the
:func:`connect` function described above. It also initializes a few
internal variables. The statement ``db = DB()`` will open the local
database with the name of the user just like ``connect()`` does.

You can also initialize the DB class with an existing :mod:`pg` or :mod:`pgdb`
connection. Pass this connection as a single unnamed parameter, or as a
single parameter named ``db``. This allows you to use all of the methods
of the DB class with a DB-API 2 compliant connection. Note that the
:meth:`Connection.close` and :meth:`Connection.reopen` methods are inoperative
in this case.

pkey -- return the primary key of a table
-----------------------------------------

.. method:: DB.pkey(table)

    Return the primary key of a table

    :param str table: name of table
    :returns: Name of the field which is the primary key of the table
    :rtype: str

This method returns the primary key of a table. For composite primary
keys, the return value will be a frozenset. Note that this raises an
exception if the table does not have a primary key.

get_databases -- get list of databases in the system
----------------------------------------------------

.. method:: DB.get_databases()

    Get the list of databases in the system

    :returns: all databases in the system
    :rtype: list

Although you can do this with a simple select, it is added here for
convenience.

get_relations -- get list of relations in connected database
------------------------------------------------------------

.. method:: DB.get_relations(kinds)

    Get the list of relations in connected database

    :param str kinds: a string or sequence of type letters
    :returns: all relations of the given kinds in the database
    :rtype: list

The type letters are ``r`` = ordinary table, ``i`` = index, ``S`` = sequence,
``v`` = view, ``c`` = composite type, ``s`` = special, ``t`` = TOAST table.
If `kinds` is None or an empty string, all relations are returned (this is
also the default). Although you can do this with a simple select, it is
added here for convenience.

get_tables -- get list of tables in connected database
------------------------------------------------------

.. method:: DB.get_tables()

    Get the list of tables in connected database

    :returns: all tables in connected database
    :rtype: list

This is a shortcut for ``get_relations('r')`` that has been added for
convenience.

get_attnames -- get the attribute names of a table
--------------------------------------------------

.. method:: DB.get_attnames(table)

    Get the attribute names of a table

    :param str table: name of table
    :returns: A dictionary -- the keys are the attribute names,
     the values are the type names of the attributes.

Given the name of a table, digs out the set of attribute names.

has_table_privilege -- check whether current user has specified table privilege
-------------------------------------------------------------------------------

.. method:: DB.has_table_privilege(table, privilege)

    Check whether current user has specified table privilege

    :param str table: the name of the table
    :param str privilege: privilege to be checked -- default is 'select'
    :returns: whether current user has specified table privilege
    :rtype: bool

Returns True if the current user has the specified privilege for the table.

get -- get a row from a database table or view
----------------------------------------------

.. method:: DB.get(table, arg, [keyname])

    Get a row from a database table or view

    :param str table:  name of table or view
    :param arg:  either a dictionary or the value to be looked up
    :param str keyname: name of field to use as key (optional)
    :returns: A dictionary - the keys are the attribute names,
      the values are the row values.

This method is the basic mechanism to get a single row. It assumes
that the key specifies a unique row. If *keyname* is not specified,
then the primary key for the table is used. If *arg* is a dictionary
then the value for the key is taken from it and it is modified to
include the new values, replacing existing values where necessary.
For a composite key, *keyname* can also be a sequence of key names.
The OID is also put into the dictionary if the table has one, but in
order to allow the caller to work with multiple tables, it is munged
as ``oid(schema.table)``.

insert -- insert a row into a database table
--------------------------------------------

.. method:: DB.insert(table, [d,] [key = val, ...])

    Insert a row into a database table

    :param str table: name of table
    :param dict d: optional dictionary of values
    :returns: the inserted values
    :rtype: dict

This method inserts a row into a table.  If the optional dictionary is
not supplied then the required values must be included as keyword/value
pairs.  If a dictionary is supplied then any keywords provided will be
added to or replace the entry in the dictionary.

The dictionary is then, if possible, reloaded with the values actually
inserted in order to pick up values modified by rules, triggers, etc.

Note: The method currently doesn't support insert into views
although PostgreSQL does.

update -- update a row in a database table
------------------------------------------

.. method:: DB.update(table, [d,] [key = val, ...])

    Update a row in a database table

    :param str table: name of table
    :param dict d: optional dictionary of values
    :returns: the new row
    :rtype: dict

Similar to insert but updates an existing row.  The update is based on the
OID value as munged by get or passed as keyword, or on the primary key of
the table.  The dictionary is modified, if possible, to reflect any changes
caused by the update due to triggers, rules, default values, etc.

Like insert, the dictionary is optional and updates will be performed
on the fields in the keywords.  There must be an OID or primary key
either in the dictionary where the OID must be munged, or in the keywords
where it can be simply the string 'oid'.

query -- execute a SQL command string
-------------------------------------

.. method:: DB.query(command, [arg1, [arg2, ...]])

    Execute a SQL command string

    :param str command: SQL command
    :param arg*: optional positional arguments
    :returns: result values
    :rtype: :class:`Query`, None
    :raises TypeError: bad argument type, or too many arguments
    :raises TypeError: invalid connection
    :raises ValueError: empty SQL query or lost connection
    :raises pg.ProgrammingError: error in query
    :raises pg.InternalError: error during query processing

Similar to the :class:`Connection` function with the same name, except that
positional arguments can be passed either as a single list or tuple, or as
individual positional arguments.

Example::

    name = input("Name? ")
    phone = input("Phone? ")
    rows = db.query("update employees set phone=$2 where name=$1",
        (name, phone)).getresult()[0][0]
    # or
    rows = db.query("update employees set phone=$2 where name=$1",
         name, phone).getresult()[0][0]

clear -- clear row values in memory
-----------------------------------

.. method:: DB.clear(table, [a])

    Clear row values in memory

    :param str table: name of table
    :param dict a: optional dictionary of values
    :returns: an empty row
    :rtype: dict

This method clears all the attributes to values determined by the types.
Numeric types are set to 0, Booleans are set to ``'f'``, dates are set
to ``'now()'`` and everything else is set to the empty string.
If the array argument is present, it is used as the array and any entries
matching attribute names are cleared with everything else left unchanged.

If the dictionary is not supplied a new one is created.

delete -- delete a row from a database table
--------------------------------------------

.. method:: DB.delete(table, [d,] [key = val, ...])

    Delete a row from a database table

    :param str table: name of table
    :param dict d: optional dictionary of values
    :rtype: None

This method deletes the row from a table.  It deletes based on the OID value
as munged by get or passed as keyword, or on the primary key of the table.
The return value is the number of deleted rows (i.e. 0 if the row did not
exist and 1 if the row was deleted).

escape_string -- escape a string for use within SQL
---------------------------------------------------

.. method:: DB.escape_string(string)

    Escape a string for use within SQL

    :param str string: the string that is to be escaped
    :returns: the escaped string
    :rtype: str

Similar to the module function with the same name, but the
behavior of this method is adjusted depending on the connection properties
(such as character encoding).

escape_bytea -- escape binary data for use within SQL
-----------------------------------------------------

.. method:: DB.escape_bytea(datastring)

    Escape binary data for use within SQL as type ``bytea``

    :param str datastring: string containing the binary data that is to be escaped
    :returns: the escaped string
    :rtype: str

Similar to the module function with the same name, but the
behavior of this method is adjusted depending on the connection properties
(in particular, whether standard-conforming strings are enabled).

unescape_bytea -- unescape data that has been retrieved as text
---------------------------------------------------------------

.. method:: DB.unescape_bytea(string)

    Unescape ``bytea`` data that has been retrieved as text

    :param datastring: the ``bytea`` data string that has been retrieved as text
    :returns: byte string containing the binary data
    :rtype: bytes

See the module function with the same name.


Query methods
=====================

.. class:: Query

The :class:`Query` object returned by :meth:`Connection.query` and
:meth:`DB.query` provides the following methods for accessing
the results of the query:

getresult -- get query values as list of tuples
-----------------------------------------------

.. method:: Query.getresult()

    Get query values as list of tuples

    :returns: result values as a list of tuples
    :rtype: list
    :raises TypeError: too many (any) parameters
    :raises MemoryError: internal memory error

This method returns the list of the values returned by the query.
More information about this result may be accessed using
:meth:`Query.listfields`, :meth:`Query.fieldname`
and :meth:`Query.fieldnum` methods.

dictresult -- get query values as list of dictionaries
------------------------------------------------------

.. method:: Query.dictresult()

    Get query values as list of dictionaries

    :returns: result values as a list of dictionaries
    :rtype: list
    :raises TypeError: too many (any) parameters
    :raises MemoryError: internal memory error

This method returns the list of the values returned by the query
with each tuple returned as a dictionary with the field names
used as the dictionary index.

namedresult -- get query values as list of named tuples
-------------------------------------------------------

.. method:: Query.namedresult()

    Get query values as list of named tuples

    :returns: result values as a list of named tuples
    :rtype: list
    :raises TypeError: too many (any) parameters
    :raises TypeError: named tuples not supported
    :raises MemoryError: internal memory error

This method returns the list of the values returned by the query
with each row returned as a named tuple with proper field names.

listfields -- list fields names of previous query result
--------------------------------------------------------

.. method:: Query.listfields()

    List fields names of previous query result

    :returns: field names
    :rtype: list
    :raises TypeError: too many parameters

This method returns the list of names of the fields defined for the
query result. The fields are in the same order as the result values.

fieldname, fieldnum -- field name/number conversion
---------------------------------------------------

.. method:: Query.fieldname(num)

    Get field name from its number

    :param int num: field number
    :returns: field name
    :rtype: str
    :raises TypeError: invalid connection, bad parameter type, or too many parameters
    :raises ValueError: invalid field number

This method allows to find a field name from its rank number. It can be
useful for displaying a result. The fields are in the same order as the
result values.

.. method:: Query.fieldnum(name)

    Get field number from its name

    :param str name: field name
    :returns: field number
    :rtype: int
    :raises TypeError: invalid connection, bad parameter type, or too many parameters
    :raises ValueError: unknown field name

This method returns a field number from its name. It can be used to
build a function that converts result list strings to their correct
type, using a hardcoded table definition. The number returned is the
field rank in the result values list.

ntuples -- return number of tuples in query object
--------------------------------------------------

.. method:: Query.ntuples()

    Return number of tuples in query object

    :returns: number of tuples in :class:`Query`
    :rtype: int
    :raises TypeError: Too many arguments.

This method returns the number of tuples found in a query.


LargeObject -- Large Objects
============================

.. class:: LargeObject

Objects that are instances of the class :class:`LargeObject` are used to handle
all the requests concerning a PostgreSQL large object. These objects embed
and hide all the "recurrent" variables (object OID and connection), exactly
in the same way :class:`Connection` instances do, thus only keeping significant
parameters in function calls. The class:`LargeObject` instance keeps a
reference to the :class:`Connection` object used for its creation, sending
requests though with its parameters. Any modification but dereferencing the
:class:`Connection` object will thus affect the :class:`LargeObject` instance.
Dereferencing the initial :class:`Connection` object is not a problem since
Python won't deallocate it before the :class:`LargeObject` instance
dereferences it. All functions return a generic error message on call error,
whatever the exact error was. The :attr:`error` attribute of the object allows
to get the exact error message.

See also the PostgreSQL programmer's guide for more information about the
large object interface.

open -- open a large object
---------------------------

.. method:: LargeObject.open(mode)

    Open a large object

    :param int mode: open mode definition
    :rtype: None
    :raises TypeError: invalid connection, bad parameter type, or too many parameters
    :raises IOError: already opened object, or open error

This method opens a large object for reading/writing, in the same way than the
Unix open() function. The mode value can be obtained by OR-ing the constants
defined in the :mod:`pg` module (:const:`INV_READ`, :const:`INV_WRITE`).

close -- close a large object
-----------------------------

.. method:: LargeObject.close()

    Close a large object

    :rtype: None
    :raises TypeError: invalid connection
    :raises TypeError: too many parameters
    :raises IOError: object is not opened, or close error

This method closes a previously opened large object, in the same way than
the Unix close() function.

read, write, tell, seek, unlink -- file-like large object handling
------------------------------------------------------------------

.. method:: LargeObject.read(size)

    Read data from large object

    :param int size: maximal size of the buffer to be read
    :returns: the read buffer
    :rtype: bytes
    :raises TypeError: invalid connection, invalid object,
     bad parameter type, or too many parameters
    :raises ValueError: if `size` is negative
    :raises IOError: object is not opened, or read error

This function allows to read data from a large object, starting at current
position.

.. method:: LargeObject.write(string)

    Read data to large object

    :param bytes string: string buffer to be written
    :rtype: None
    :raises TypeError: invalid connection, bad parameter type, or too many parameters
    :raises IOError: object is not opened, or write error

This function allows to write data to a large object, starting at current
position.

.. method:: LargeObject.seek(offset, whence)

    Change current position in large object

    :param int offset: position offset
    :param int whence: positional parameter
    :returns: new position in object
    :rtype: int
    :raises TypeError: invalid connection or invalid object,
     bad parameter type, or too many parameters
    :raises IOError: object is not opened, or seek error

This method allows to move the position cursor in the large object.
The valid values for the whence parameter are defined as constants in the
:mod:`pg` module (:const:`SEEK_SET`, :const:`SEEK_CUR`, :const:`SEEK_END`).

.. method:: LargeObject.tell()

    Return current position in large object

    :returns: current position in large object
    :rtype: int
    :raises TypeError: invalid connection or invalid object
    :raises TypeError: too many parameters
    :raises IOError: object is not opened, or seek error

This method allows to get the current position in the large object.

.. method:: LargeObject.unlink()

    Delete large object

    :rtype: None
    :raises TypeError: invalid connection or invalid object
    :raises TypeError: too many parameters
    :raises IOError: object is not closed, or unlink error

This methods unlinks (deletes) the PostgreSQL large object.

size -- get the large object size
---------------------------------

.. method:: LargeObject.size()

    Return the large object size

    :returns: the large object size
    :rtype: int
    :raises TypeError: invalid connection or invalid object
    :raises TypeError: too many parameters
    :raises IOError: object is not opened, or seek/tell error

This (composite) method allows to get the size of a large object. It was
implemented because this function is very useful for a web interfaced
database. Currently, the large object needs to be opened first.

export -- save a large object to a file
---------------------------------------

.. method:: LargeObject.export(name)

    Export a large object to a file

    :param str name: file to be created
    :rtype: None
    :raises TypeError: invalid connection or invalid object,
     bad parameter type, or too many parameters
    :raises IOError: object is not closed, or export error

This methods allows to dump the content of a large object in a very simple
way. The exported file is created on the host of the program, not the
server host.

Object attributes
-----------------
:class:`LargeObject` objects define a read-only set of attributes that allow
to get some information about it. These attributes are:

.. attribute:: LargeObject.oid

   the OID associated with the large object (int)

.. attribute:: LargeObject.pgcnx

   the :class:`Connection` object associated with the large object

.. attribute:: LargeObject.error

   the last warning/error message of the connection (str)

.. note::

    **Be careful**:
    In multithreaded environments, :attr:`LargeObject.error` may be modified by
    another thread using the same :class:`Connection`. Remember these object
    are shared, not duplicated. You should provide some locking to be able
    if you want to check this. The :attr:`LargeObject.oid` attribute is very
    interesting, because it allows you to reuse the OID later, creating the
    :class:`LargeObject` object with a :meth:`Connection.getlo` method call.
